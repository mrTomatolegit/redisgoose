# Redisgoose

Use redis and mongoose together as efficiently as possible

I created this package because cachegoose and recachegoose were giving me some trouble

> Made for Mongoose v6 and up

# Installation

```
npm i redisgoose
```

# Example Usage

```js
const redisgoose = require('redisgoose');
const mongoose = require('mongoose');

// Redis is installed locally in this case
redisgoose('redis://127.0.0.1:6379');

const Sample = mongoose.model('sample', new mongoose.Schema({ name: String }));

const main = async function () {
    await mongoose.connect('mongodb://127.0.0.1/test');
    console.log('Connected to mongodb');

    // Find a sample with the name test
    // .cache(lifetime, ?key), key should be autogenerated or predefined

    let q = { name: 'test' };
    const r1 = await Sample.findOne(q).cache(500, Sample.makeCacheKey(q));
    console.log(r1);

    if (!r1) {
        // Creates a sample if doesn't exist
        await Sample.create(q);
    }

    const r2 = await Sample.findOne(q).cache(500, Sample.makeCacheKey(q));
    // If r1 is null then r2 will be null due to it being cached, this means it works
    console.log(r2);

    // To clear the cache just use this
    redisgoose.clearCache(Sample.makeCacheKey(q));
};

main();

```

# Example initialisation

```js
const redisgoose = require('redisgoose');
// If redis is installed locally and with default port
redisgoose();

// With redis url
// redis[s]://[[username][:password]@][host][:port][/db-number]
redisgoose('redis://127.0.0.1:6379');

// With host and port explicit
redisgoose({
    host: '127.0.0.1',
    port: '6379'
});

// With a preinitialised redis client
redisgoose(client);
redisgoose({ client: client });
```

# API

This api section is partially defined

This module is equipped with typescript type definitions\
The typescript has full documentation

## redisgoose

### redisgoose.clearCache(key?)

Clears the cached value for the given key

If no key is provided then all cached values will be uncached

Returns: `Promise<void>`

## Queue

### Queue.redisManager

The redis manager initialised with the process

### Query.prototype.cache(lifetime, key?)

Indicates the lifetime and may indicate the key
This is required to cache a query to Redis
This enables `cacheResult`

`lifetime`:\
The lifetime in seconds\
Type: `number`

`key`:\
The string to use as key (recommended)\
Type: `string`

Returns: `this`

### Query.prototype.force()

Sets `checkCache` to false\
This bypasses checking Redis cache and requests MongoDB directly

Returns `this`

### Query.prototype.noSave()

This prevents saving the query result to Redis\
Sets `cacheResult` to false\
Implemented for convenience/function chaining

Returns `this`

### Query.prototype.setCacheKey(key)

Sets the cache key

The difference with `.cache` is that this doesn't enable `cacheResult`\
This can be used if you need to `checkCache` but not `cacheResult`

`key`:\
The string to use as key\
Type: `string`

Returns: `this`

### Queue.prototype.checkCache

Whether to check Redis cache when executing a query

Type: `boolean`

Default: `true`

### Queue.prototype.cacheKey

The key to cache the result with\
This will default to a stringification of the query data if no key is provided

Type: `string`

Default: `null`

### Query.prototype.cacheLifetime

The lifetime for the cached result in Redis memory

Type: `number`

Default: `null`

### Queue.prototype.cacheResult

Whether to cache the result to Redis when the query is completed

Type: `boolean`

Default: `true`


# Example key generator

```js
/**
 *
 * @param model A mongoose model
 * @param args The chaining arguments for the key
 *
 */
function makeCacheKey(model, ...args) {
    return `${model.modelName}:${args.join(':')}`
}
```
